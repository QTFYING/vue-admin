# 说明

在 JS 函数中，策略模式通常是用一个映射对象（Map/Object）来替代冗长的 if-else 或 switch。

在组件封装中，核心逻辑是一样的，只是我们将算法替换成了组件。

## 核心概念映射

| 策略模式角色     | JS 函数中的形态                    | 组件封装中的形态  |
| ---------------- | ---------------------------------- | ----------------- |
| Context (环境)   | 调用函数的逻辑                     | 容器组件          |
| Strategy (策略)  | 具体执行的函数                     | 子组件 / 业务组件 |
| Key (索引)       | 函数名或状态字符串,组件类型 (Type) | 映射 Key          |
| Interface (接口) | 函数的入参签名                     | 组件的 Props 定义 |

## 场景举例：多类型卡片渲染

假设你需要渲染一个“动态流（Feed）”，里面包含：文本卡片、图片卡片、视频卡片。

### ❌ 传统的写法 (if/else 噩梦)

当组件类型增多时，父组件会变得极其臃肿，且每次新增类型都要修改父组件（违反开闭原则）。

```tsx
const FeedItem = ({ data }) => {
  if (data.type === 'text') {
    return <TextCard content={data.content} />;
  } else if (data.type === 'image') {
    return <ImageCard src={data.url} />;
  } else if (data.type === 'video') {
    return <VideoCard videoId={data.id} />;
  }
  return null;
};
```

### ✅ 策略模式写法 (组件映射)

我们可以利用对象映射（在 React 中）或 动态组件（在 Vue 中）来实现。

#### React 实现方案

在 React 中，组件本身就是对象/函数，可以直接存放在对象中。

```tsx
import TextCard from './TextCard';
import ImageCard from './ImageCard';
import VideoCard from './VideoCard';

// 1. 定义策略表 (Strategy Map)
// key 是后端返回的 type，value 是对应的组件
const CARD_STRATEGIES = {
  text: TextCard,
  image: ImageCard,
  video: VideoCard,
  // 方便扩展：新增类型只需在这里加一行，无需修改下方逻辑
  default: () => <div>未知类型</div>,
};

// 2. Context (父组件)
const FeedItem = ({ data }) => {
  // 根据 type 获取具体的策略组件
  const Component = CARD_STRATEGIES[data.type] || CARD_STRATEGIES.default;

  // 3. 执行策略 (渲染组件)
  // 注意：所有策略组件必须遵守统一的 Props 接口 (即 Interface)
  return <Component {...data} />;
};
```

#### Vue 实现方案

Vue 提供了非常强大的 <component :is="..."> 语法，天生支持策略模式。

```vue
<template>
  <component :is="componentMap[data.type]" :data="data" />
</template>

<script setup>
  import TextCard from './TextCard.vue';
  import ImageCard from './ImageCard.vue';
  import VideoCard from './VideoCard.vue';

  const props = defineProps(['data']);

  // 1. 定义策略表
  const componentMap = {
    text: TextCard,
    image: ImageCard,
    video: VideoCard,
  };
</script>
```

### 关键点：统一接口 (Standardized Props)

在函数策略模式中，所有策略函数通常接收相同的参数。同样，在组件策略模式中，所有策略组件必须接受统一的 Props 结构，或者父组件将所有数据透传。

如果策略组件需要的 Props 差异巨大，通常有两种处理方式：

- 透传所有数据 (Pass-through): 父组件直接把整个 data 对象传给子组件，子组件自己去取需要字段。
  优点: 父组件极度解耦。
  缺点: 子组件内部可能需要做数据适配。
- 适配器层 (Adapter): 在策略表中加一层处理函数，但这会增加复杂度，通常不建议。

### 带来的好处

使用策略模式封装组件后，可以轻松演进为 Server-Driven UI (服务端驱动 UI)。

- 远程策略注册: 后端不仅返回数据，还可以返回组件的名称。前端维护一个全局的 ComponentRegistry（策略池）。
- 异步加载策略: 策略表中的值可以是 lazy 加载的组件，从而实现按需加载，优化首屏性能。

```tsx
// React 懒加载策略
const STRATEGIES = {
  chart: React.lazy(() => import('./ComplexChart')),
  table: React.lazy(() => import('./BigTable')),
};
```

> **总结**
> 符合开闭原则 (Open/Closed): 新增组件类型只需更新映射表，无需修改父组件逻辑。
> 逻辑清晰: 移除了复杂的 switch/if-else 模板代码。
> 可维护性: 每个具体组件（策略）独立维护，互不干扰。
